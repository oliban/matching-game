<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drag & Drop Bubble Game</title>
    <style>
        body { display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { background: #f0f0f0; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1200" height="600"></canvas>
    <script>

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Constants for rectangle and canvas dimensions
    const totalRows = 3;
    const totalRects = totalRows*3; // Total number of rectangles
    const rectWidth = 300; // Width of each rectangle
    const rectHeight = 50; // Height of each rectangle
    const canvasWidth = canvas.width; // The canvas width
    const canvasHeight = canvas.height; // The canvas height
    const rectsPerRow = Math.ceil(Math.sqrt(totalRects)); // Calculate the number of rectangles per row for a square-ish layout

    let isDragging = false;
    let dragTarget = null;

    function drawBubble(bubble) {
        ctx.fillStyle = bubble.color;
        // Calculate rectangle position and size
        const rectX = bubble.x - rectWidth / 2; // Center the rectangle on the bubble's x coordinate
        const rectY = bubble.y - rectHeight / 2; // Center the rectangle on the bubble's y coordinate

        ctx.fillRect(rectX, rectY, rectWidth, rectHeight);

        // Drawing text with the same logic as before
        ctx.fillStyle = 'white'; // Text color for contrast
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        let text = bubble.text || "No Data";
        ctx.fillText(text, bubble.x, bubble.y); // Text is centered on the bubble's coordinates
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
        bubbles.forEach(drawBubble); // Redraw all bubbles
    }

    canvas.addEventListener('mousedown', function(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        bubbles.forEach(bubble => {
            const rectX = bubble.x - rectWidth / 2;
            const rectY = bubble.y - rectHeight / 2;
            if (x >= rectX && x <= rectX + rectWidth && y >= rectY && y <= rectY + rectHeight) {
                dragTarget = bubble;
                isDragging = true;
                return; // Break out of the loop once the correct bubble is found
            }
        });
    });


    canvas.addEventListener('mousemove', function(e) {
        if (isDragging && dragTarget) {
            const rect = canvas.getBoundingClientRect();
            dragTarget.x = e.clientX - rect.left;
            dragTarget.y = e.clientY - rect.top;
            draw();
        }
    });

    canvas.addEventListener('mouseup', function() {
        if (isDragging && dragTarget) {
            let matchFound = false;

            for (let i = 0; i < bubbles.length; i++) {
                let bubble = bubbles[i];
                console.log('Drag target:', dragTarget);
                console.log('Comparing to bubble:', bubble);
                console.log('Overlap detected:', rectanglesOverlap(dragTarget, bubble));

                if (bubble !== dragTarget && rectanglesOverlap({
                    x: dragTarget.x, y: dragTarget.y, width: 300, height: 50
                }, {
                    x: bubble.x, y: bubble.y, width: 300, height: 50
                })) {
                    if (dragTarget.attributes.name === bubble.attributes.name ||
                        dragTarget.attributes.title === bubble.attributes.title ||
                        dragTarget.attributes.age === bubble.attributes.age) {
                        matchFound = true;
                        dragTarget.color = bubble.color = 'green'; // Indicate a match
                        break; // Exit the loop after finding a match
                    }
                }
            }

            if (!matchFound && dragTarget.originalColor) {
                dragTarget.color = dragTarget.originalColor;
            }

            draw(); // Redraw the canvas to reflect the changes
            isDragging = false;
            dragTarget = null;
        }
    });


    function calculateGridPosition(index, rectsPerRow, rectWidth, rectHeight, canvasWidth, canvasHeight) {
        // Calculate the horizontal and vertical gaps between rectangles
        const horizontalGap = (canvasWidth - (rectsPerRow * rectWidth)) / (rectsPerRow + 1);
        const verticalGap = (canvasHeight - (rectHeight * Math.ceil(totalRects / rectsPerRow))) / (Math.ceil(totalRects / rectsPerRow) + 1);

        // Calculate the row and column for the current index
        const row = Math.floor(index / rectsPerRow);
        const column = index % rectsPerRow;

        // Calculate the x and y position for the rectangle
        const x = horizontalGap + (column * (rectWidth + horizontalGap) + rectWidth/2);
        const y = verticalGap + (row * (rectHeight + verticalGap));

        return { x, y };
    }

    function revertToOriginalColor(bubble) {
        if (bubble.color === 'green') {
            bubble.color = bubble.originalColor; // Revert color
        }
    }

    function rectanglesOverlap(rectA, rectB) {
        return !(rectA.x + rectA.width / 2 < rectB.x - rectB.width / 2 || 
                 rectA.x - rectA.width / 2 > rectB.x + rectB.width / 2 || 
                 rectA.y + rectA.height / 2 < rectB.y - rectB.height / 2 || 
                 rectA.y - rectA.height / 2 > rectB.y + rectB.height / 2);
    }

    function checkOverlapAndChangeColor() {
        for (let i = 0; i < bubbles.length; i++) {
            for (let j = i + 1; j < bubbles.length; j++) {
                let dx = bubbles[i].x - bubbles[j].x;
                let dy = bubbles[i].y - bubbles[j].y;
                let distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < bubbles[i].radius + bubbles[j].radius) {
                    // Overlap detected, change colors
                    bubbles[i].color = getRandomColor();
                    bubbles[j].color = getRandomColor();
                }
            }
        }
    }

    function getRandomColor() {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }

    function calculateXPosition(index, isTitle) {
        // Assuming a grid layout with 10 bubbles per row
        let column = index % 10;
        // Offset titles and ages slightly
        let offset = isTitle ? 0 : 40;
        return column * 80 + offset + 50; // +50 for some padding from canvas edge
    }

    function calculateYPosition(index, isTitle) {
        // Assuming a grid layout with 10 bubbles per row
        let row = Math.floor(index / 10);
        // Offset titles and ages slightly
        let offset = isTitle ? 0 : 20;
        return row * 80 + offset + 50; // +50 for some padding from canvas top
    }

    function fetchEmployeeDataAndGenerateBubbles() {
        fetch('/data')
        .then(response => response.json())
        .then(data => {
            bubbles = []; // Clear any existing bubbles


            const selectedRows = data.slice(0, totalRows); 
            selectedRows.forEach((employee, index) => {
                console.log(index);

                const position = calculateGridPosition(index, rectsPerRow, rectWidth, rectHeight, canvasWidth, canvasHeight);

                bubbles.push({
                    x: position.x,
                    y: position.y,
                    width: rectWidth,
                    height: rectHeight,
                    color: 'purple',
                    originalColor: 'purple',
                    text: employee['Name'],
                    attributes: {
                        name: employee['Name'],
                        title: employee['Employee Title'],
                        age: employee['Age'].toString()
                    },
                    type: 'name' 
                });

                bubbles.push({
                    x: position.x,
                    y: position.y+rectHeight,
                    width: rectWidth,
                    height: rectHeight,
                    color: 'blue',
                    originalColor: 'blue',
                    text: employee['Employee Title'],
                    attributes: {
                        name: employee['Name'],
                        title: employee['Employee Title'],
                        age: employee['Age'].toString()
                    },
                    type: 'title'
                });

                bubbles.push({
                    x: position.x,
                    y: position.y+rectHeight+rectHeight,
                    width: rectWidth,
                    height: rectHeight,
                    color: 'red',
                    originalColor: 'red',
                    text: employee['Age'].toString(),
                    attributes: {
                        name: employee['Name'],
                        title: employee['Employee Title'],
                        age: employee['Age'].toString()
                    },
                    type: 'age'
                });
            });

            draw(); 
        });

    }

    // Modify your existing draw function or event listeners as necessary to handle the new game logic

    // Call the function to fetch data and generate bubbles when the game loads
    window.onload = fetchEmployeeDataAndGenerateBubbles;
    </script>
</body>
</html>
